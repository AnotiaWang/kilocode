import { jest } from "@jest/globals";
import { DEFAULT_TOOL_POLICIES } from "../permissions/defaultPolicies.js";
import { ToolPermissionPolicy } from "../permissions/types.js";

// Mock the dependencies
jest.unstable_mockModule("../util/logger.js", () => ({
  default: {
    debug: jest.fn(),
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
  },
}));

jest.unstable_mockModule("../permissions/precedenceResolver.js", () => ({
  resolvePermissionPrecedence: jest.fn(),
}));

jest.unstable_mockModule("../permissions/permissionsYamlLoader.js", () => ({
  ensurePermissionsYamlExists: jest.fn(),
  loadPermissionsYaml: jest.fn(),
  yamlConfigToPolicies: jest.fn(),
  PERMISSIONS_YAML_PATH: "/home/user/.continue/permissions.yaml",
}));

// Import after mocking
const precedenceResolver = await import("../permissions/precedenceResolver.js");
const permissionsYamlLoader = await import("../permissions/permissionsYamlLoader.js");
const { ToolPermissionService } = await import("./ToolPermissionService.js");

const mockPrecedenceResolver = precedenceResolver as jest.Mocked<
  typeof precedenceResolver
>;
const mockPermissionsYamlLoader = permissionsYamlLoader as jest.Mocked<
  typeof permissionsYamlLoader
>;

describe("ToolPermissionService", () => {
  let service: InstanceType<typeof ToolPermissionService>;

  beforeEach(() => {
    jest.clearAllMocks();
    service = new ToolPermissionService();

    // Default mock for ensurePermissionsYamlExists
    mockPermissionsYamlLoader.ensurePermissionsYamlExists.mockResolvedValue(
      undefined
    );
  });

  describe("initialization", () => {
    it("should initialize with default policies when no overrides provided", async () => {
      mockPrecedenceResolver.resolvePermissionPrecedence.mockReturnValue(
        DEFAULT_TOOL_POLICIES
      );

      const state = await service.initialize();

      expect(
        mockPrecedenceResolver.resolvePermissionPrecedence
      ).toHaveBeenCalledWith({
        commandLineFlags: undefined,
        personalSettings: true,
        useDefaults: true,
      });
      expect(state.permissions.policies).toEqual(DEFAULT_TOOL_POLICIES);
      expect(state.permissions.policies.length).toBe(
        DEFAULT_TOOL_POLICIES.length
      );
    });

    it("should use precedence resolver with runtime overrides", async () => {
      const overrides = {
        allow: ["TestTool1"],
        ask: ["TestTool2"],
        exclude: ["TestTool3"],
      };

      const expectedPolicies: ToolPermissionPolicy[] = [
        { tool: "TestTool3", permission: "exclude" },
        { tool: "TestTool2", permission: "ask" },
        { tool: "TestTool1", permission: "allow" },
        ...DEFAULT_TOOL_POLICIES,
      ];

      mockPrecedenceResolver.resolvePermissionPrecedence.mockReturnValue(
        expectedPolicies
      );

      const state = await service.initialize(overrides);
      const policies = state.permissions.policies;

      expect(
        mockPrecedenceResolver.resolvePermissionPrecedence
      ).toHaveBeenCalledWith({
        commandLineFlags: overrides,
        personalSettings: true,
        useDefaults: true,
      });
      expect(policies).toEqual(expectedPolicies);
    });

    it("should handle empty override arrays", async () => {
      const overrides = {
        allow: [],
        ask: [],
        exclude: [],
      };

      mockPrecedenceResolver.resolvePermissionPrecedence.mockReturnValue(
        DEFAULT_TOOL_POLICIES
      );

      const state = await service.initialize(overrides);

      expect(
        mockPrecedenceResolver.resolvePermissionPrecedence
      ).toHaveBeenCalledWith({
        commandLineFlags: overrides,
        personalSettings: true,
        useDefaults: true,
      });
      expect(state.permissions.policies).toEqual(DEFAULT_TOOL_POLICIES);
    });

    it("should handle partial overrides", async () => {
      const overrides = {
        allow: ["OnlyAllowTool"],
        // ask and exclude are undefined
      };

      const expectedPolicies: ToolPermissionPolicy[] = [
        { tool: "OnlyAllowTool", permission: "allow" },
        ...DEFAULT_TOOL_POLICIES,
      ];

      mockPrecedenceResolver.resolvePermissionPrecedence.mockReturnValue(
        expectedPolicies
      );

      const state = await service.initialize(overrides);
      const policies = state.permissions.policies;

      expect(
        mockPrecedenceResolver.resolvePermissionPrecedence
      ).toHaveBeenCalledWith({
        commandLineFlags: overrides,
        personalSettings: true,
        useDefaults: true,
      });
      expect(policies).toEqual(expectedPolicies);
    });

    it("should handle multiple tools in same override category", async () => {
      const overrides = {
        exclude: ["Tool1", "Tool2", "Tool3"],
      };

      const expectedPolicies: ToolPermissionPolicy[] = [
        { tool: "Tool1", permission: "exclude" },
        { tool: "Tool2", permission: "exclude" },
        { tool: "Tool3", permission: "exclude" },
        ...DEFAULT_TOOL_POLICIES,
      ];

      mockPrecedenceResolver.resolvePermissionPrecedence.mockReturnValue(
        expectedPolicies
      );

      const state = await service.initialize(overrides);
      const policies = state.permissions.policies;

      expect(
        mockPrecedenceResolver.resolvePermissionPrecedence
      ).toHaveBeenCalledWith({
        commandLineFlags: overrides,
        personalSettings: true,
        useDefaults: true,
      });
      expect(policies).toEqual(expectedPolicies);
    });
  });

  describe("getState", () => {
    it("should return current state after initialization", async () => {
      mockPrecedenceResolver.resolvePermissionPrecedence.mockReturnValue(
        DEFAULT_TOOL_POLICIES
      );

      await service.initialize();
      const state = service.getState();

      expect(state).toBeDefined();
      expect(state.permissions).toBeDefined();
      expect(state.permissions.policies).toEqual(DEFAULT_TOOL_POLICIES);
    });

    it("should return state with overrides", async () => {
      const overrides = {
        allow: ["TestTool"],
      };

      const expectedPolicies: ToolPermissionPolicy[] = [
        { tool: "TestTool", permission: "allow" },
        ...DEFAULT_TOOL_POLICIES,
      ];

      mockPrecedenceResolver.resolvePermissionPrecedence.mockReturnValue(
        expectedPolicies
      );

      await service.initialize(overrides);
      const state = service.getState();

      expect(state.permissions.policies[0]).toEqual({
        tool: "TestTool",
        permission: "allow",
      });
    });
  });

  describe("getPermissions", () => {
    it("should return permissions object", async () => {
      mockPrecedenceResolver.resolvePermissionPrecedence.mockReturnValue(
        DEFAULT_TOOL_POLICIES
      );

      await service.initialize();
      const permissions = service.getPermissions();

      expect(permissions).toBeDefined();
      expect(permissions.policies).toEqual(DEFAULT_TOOL_POLICIES);
    });
  });

  describe("updatePermissions", () => {
    it("should replace all policies with new ones", async () => {
      mockPrecedenceResolver.resolvePermissionPrecedence.mockReturnValue(
        DEFAULT_TOOL_POLICIES
      );

      await service.initialize();

      const newPolicies: ToolPermissionPolicy[] = [
        { tool: "NewTool1", permission: "allow" },
        { tool: "NewTool2", permission: "ask" },
      ];

      service.updatePermissions(newPolicies);
      const state = service.getState();

      expect(state.permissions.policies).toEqual(newPolicies);
      expect(state.permissions.policies.length).toBe(2);
    });

    it("should handle empty policy updates", () => {
      service.updatePermissions([]);
      const state = service.getState();

      expect(state.permissions.policies).toEqual([]);
    });
  });

  describe("override precedence", () => {
    it("should give precedence to runtime overrides over defaults", async () => {
      // Assuming read_file has a default policy
      const overrides = {
        exclude: ["read_file"],
      };

      // Mock the precedence resolver to return the expected order
      const expectedPolicies: ToolPermissionPolicy[] = [
        { tool: "read_file", permission: "exclude" }, // Override comes first
        ...DEFAULT_TOOL_POLICIES,
      ];

      mockPrecedenceResolver.resolvePermissionPrecedence.mockReturnValue(
        expectedPolicies
      );

      const state = await service.initialize(overrides);
      const policies = state.permissions.policies;

      expect(
        mockPrecedenceResolver.resolvePermissionPrecedence
      ).toHaveBeenCalledWith({
        commandLineFlags: overrides,
        personalSettings: true,
        useDefaults: true,
      });

      // The exclude override should come first
      expect(policies[0]).toEqual({ tool: "read_file", permission: "exclude" });
    });
  });

  describe("wildcard support", () => {
    it("should support wildcard patterns in overrides", async () => {
      const overrides = {
        allow: ["mcp__*"],
        exclude: ["write_*"],
      };

      const expectedPolicies: ToolPermissionPolicy[] = [
        { tool: "write_*", permission: "exclude" },
        { tool: "mcp__*", permission: "allow" },
        ...DEFAULT_TOOL_POLICIES,
      ];

      mockPrecedenceResolver.resolvePermissionPrecedence.mockReturnValue(
        expectedPolicies
      );

      const state = await service.initialize(overrides);
      const policies = state.permissions.policies;

      expect(
        mockPrecedenceResolver.resolvePermissionPrecedence
      ).toHaveBeenCalledWith({
        commandLineFlags: overrides,
        personalSettings: true,
        useDefaults: true,
      });
      expect(policies).toEqual(expectedPolicies);
    });
  });

  describe("ensurePermissionsYamlExists", () => {
    it("should ensure permissions.yaml exists during async initialization", async () => {
      mockPrecedenceResolver.resolvePermissionPrecedence.mockReturnValue(
        DEFAULT_TOOL_POLICIES
      );

      await service.initialize();

      expect(
        mockPermissionsYamlLoader.ensurePermissionsYamlExists
      ).toHaveBeenCalled();
    });

    it("should not call ensurePermissionsYamlExists during sync initialization", () => {
      mockPrecedenceResolver.resolvePermissionPrecedence.mockReturnValue(
        DEFAULT_TOOL_POLICIES
      );

      service.initializeSync();

      expect(
        mockPermissionsYamlLoader.ensurePermissionsYamlExists
      ).not.toHaveBeenCalled();
    });
  });
});
