import type { DisplayMessage } from "../ui/types.js";

export interface UIValidationHelpers {
  findMessageByContent: (messages: DisplayMessage[], content: string) => DisplayMessage | undefined;
  findMessagesByRole: (messages: DisplayMessage[], role: string) => DisplayMessage[];
  findToolMessages: (messages: DisplayMessage[], toolName?: string) => DisplayMessage[];
  validateStreamingState: (messages: DisplayMessage[], index: number, shouldBeStreaming: boolean) => void;
  validateToolExecution: (messages: DisplayMessage[], toolName: string, expectedResult?: string) => void;
  validateMessageOrder: (messages: DisplayMessage[], expectedOrder: Array<{role: string, content?: string}>) => void;
  validateNoErrors: (messages: DisplayMessage[]) => void;
  extractToolResults: (messages: DisplayMessage[]) => Array<{toolName: string, result: string}>;
  validateMarkdownFormatting: (message: DisplayMessage, expectedFormats: string[]) => void;
}

export const uiValidationHelpers: UIValidationHelpers = {
  findMessageByContent: (messages: DisplayMessage[], content: string): DisplayMessage | undefined => {
    return messages.find(m => m.content.includes(content));
  },

  findMessagesByRole: (messages: DisplayMessage[], role: string): DisplayMessage[] => {
    return messages.filter(m => m.role === role);
  },

  findToolMessages: (messages: DisplayMessage[], toolName?: string): DisplayMessage[] => {
    return messages.filter(m => {
      const isToolMessage = m.messageType?.startsWith("tool");
      if (!toolName) return isToolMessage;
      return isToolMessage && m.toolName === toolName;
    });
  },

  validateStreamingState: (messages: DisplayMessage[], index: number, shouldBeStreaming: boolean): void => {
    const message = messages[index];
    if (!message) {
      throw new Error(`No message found at index ${index}`);
    }
    
    if (shouldBeStreaming && !message.isStreaming) {
      throw new Error(`Expected message at index ${index} to be streaming`);
    }
    
    if (!shouldBeStreaming && message.isStreaming) {
      throw new Error(`Expected message at index ${index} to not be streaming`);
    }
  },

  validateToolExecution: (messages: DisplayMessage[], toolName: string, expectedResult?: string): void => {
    const toolStartMsg = messages.find(m => 
      m.messageType === "tool-start" && m.toolName === toolName
    );
    
    if (!toolStartMsg) {
      throw new Error(`No tool start message found for tool "${toolName}"`);
    }

    const toolStartIndex = messages.indexOf(toolStartMsg);
    const toolResultMsg = messages.slice(toolStartIndex).find(m => 
      m.messageType === "tool-result" && m.toolName === toolName
    );

    if (!toolResultMsg) {
      throw new Error(`No tool result message found for tool "${toolName}"`);
    }

    if (expectedResult && !toolResultMsg.toolResult?.includes(expectedResult)) {
      throw new Error(
        `Expected tool result to contain "${expectedResult}" but got "${toolResultMsg.toolResult}"`
      );
    }
  },

  validateMessageOrder: (messages: DisplayMessage[], expectedOrder: Array<{role: string, content?: string}>): void => {
    if (messages.length < expectedOrder.length) {
      throw new Error(
        `Expected at least ${expectedOrder.length} messages but found ${messages.length}`
      );
    }

    expectedOrder.forEach((expected, index) => {
      const actual = messages[index];
      
      if (actual.role !== expected.role) {
        throw new Error(
          `Expected message ${index} to have role "${expected.role}" but got "${actual.role}"`
        );
      }

      if (expected.content && !actual.content.includes(expected.content)) {
        throw new Error(
          `Expected message ${index} to contain "${expected.content}" but got "${actual.content}"`
        );
      }
    });
  },

  validateNoErrors: (messages: DisplayMessage[]): void => {
    const errorMessages = messages.filter(m => m.messageType === "tool-error");
    
    if (errorMessages.length > 0) {
      const errors = errorMessages.map(m => m.toolResult || m.content).join(", ");
      throw new Error(`Found ${errorMessages.length} error messages: ${errors}`);
    }
  },

  extractToolResults: (messages: DisplayMessage[]): Array<{toolName: string, result: string}> => {
    return messages
      .filter(m => m.messageType === "tool-result")
      .map(m => ({
        toolName: m.toolName || "unknown",
        result: m.toolResult || m.content,
      }));
  },

  validateMarkdownFormatting: (message: DisplayMessage, expectedFormats: string[]): void => {
    const content = message.content;
    
    const formatChecks: Record<string, RegExp> = {
      bold: /\*\*[^*]+\*\*/,
      italic: /\*[^*]+\*|_[^_]+_/,
      code: /`[^`]+`/,
      codeBlock: /```[\s\S]*?```/,
      heading: /^#+\s/m,
      link: /\[([^\]]+)\]\(([^)]+)\)/,
      list: /^[\*\-]\s/m,
      numberedList: /^\d+\.\s/m,
    };

    for (const format of expectedFormats) {
      const regex = formatChecks[format];
      if (!regex) {
        throw new Error(`Unknown markdown format: ${format}`);
      }

      if (!regex.test(content)) {
        throw new Error(
          `Expected message to contain ${format} formatting but it was not found`
        );
      }
    }
  },
};

// Advanced validation scenarios
export interface ValidationScenario {
  name: string;
  validate: (messages: DisplayMessage[]) => void;
}

export const commonValidationScenarios: Record<string, ValidationScenario> = {
  simpleQA: {
    name: "Simple Q&A",
    validate: (messages) => {
      const userMessages = uiValidationHelpers.findMessagesByRole(messages, "user");
      const assistantMessages = uiValidationHelpers.findMessagesByRole(messages, "assistant");
      
      if (userMessages.length === 0) {
        throw new Error("Expected at least one user message");
      }
      
      if (assistantMessages.length !== userMessages.length) {
        throw new Error("Expected equal number of user and assistant messages");
      }
    },
  },

  toolUsageFlow: {
    name: "Tool Usage Flow",
    validate: (messages) => {
      const toolStarts = messages.filter(m => m.messageType === "tool-start");
      const toolResults = messages.filter(m => m.messageType === "tool-result");
      
      if (toolStarts.length !== toolResults.length) {
        throw new Error(
          `Tool execution mismatch: ${toolStarts.length} starts, ${toolResults.length} results`
        );
      }
      
      uiValidationHelpers.validateNoErrors(messages);
    },
  },

  errorRecovery: {
    name: "Error Recovery",
    validate: (messages) => {
      const errors = messages.filter(m => m.messageType === "tool-error");
      
      if (errors.length === 0) {
        throw new Error("Expected at least one error message");
      }
      
      // Check that there's a recovery message after each error
      errors.forEach((error, index) => {
        const errorIndex = messages.indexOf(error);
        const nextAssistantMsg = messages
          .slice(errorIndex + 1)
          .find(m => m.role === "assistant");
          
        if (!nextAssistantMsg) {
          throw new Error(`No recovery message found after error ${index + 1}`);
        }
      });
    },
  },

  streamingContent: {
    name: "Streaming Content",
    validate: (messages) => {
      const assistantMessages = uiValidationHelpers.findMessagesByRole(messages, "assistant");
      
      const hasStreamingContent = assistantMessages.some(m => 
        m.isStreaming !== undefined && m.content.length > 0
      );
      
      if (!hasStreamingContent) {
        throw new Error("Expected at least one message with streaming content");
      }
    },
  },
};

// Helper to create custom validators
export function createCustomValidator(
  name: string,
  validator: (messages: DisplayMessage[]) => void
): ValidationScenario {
  return { name, validate: validator };
}

// Composite validators
export function combineValidators(...validators: Array<(messages: DisplayMessage[]) => void>): (messages: DisplayMessage[]) => void {
  return (messages: DisplayMessage[]) => {
    validators.forEach(validator => validator(messages));
  };
}

export function validateMessageSequence(sequence: Array<{
  role: string;
  contentPattern?: RegExp;
  messageType?: string;
}>): (messages: DisplayMessage[]) => void {
  return (messages: DisplayMessage[]) => {
    sequence.forEach((expected, index) => {
      const actual = messages[index];
      
      if (!actual) {
        throw new Error(`Expected message at index ${index} but found none`);
      }
      
      if (actual.role !== expected.role) {
        throw new Error(
          `Message ${index}: expected role "${expected.role}" but got "${actual.role}"`
        );
      }
      
      if (expected.contentPattern && !expected.contentPattern.test(actual.content)) {
        throw new Error(
          `Message ${index}: content does not match expected pattern`
        );
      }
      
      if (expected.messageType && actual.messageType !== expected.messageType) {
        throw new Error(
          `Message ${index}: expected type "${expected.messageType}" but got "${actual.messageType}"`
        );
      }
    });
  };
}