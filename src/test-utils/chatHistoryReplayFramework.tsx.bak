import React from "react";
import { render } from "ink-testing-library";
import type { ChatCompletionMessageParam } from "openai/resources/index.js";
import { TUIChat } from "../ui/TUIChat.js";
import type { ChatHistoryTestScenario, ChatHistoryTestStep } from "./chatHistoryTestUtils.js";
import { StaticMockLLMHandler, type MockLLMHandler } from "./mockLLMHandler.js";
import type { BaseLlmApi } from "@continuedev/openai-adapters";
import type { StreamCallbacks } from "../streamChatResponse.js";

export interface ChatReplayTestContext {
  component: ReturnType<typeof render>;
  messages: any[];
  chatHistory: ChatCompletionMessageParam[];
  mockHandler: MockLLMHandler;
  lastStdout: string;
  stdout: string[];
  rerender: () => void;
}

export interface ChatReplayOptions {
  sessionId?: string;
  model?: string;
  skipInitialRender?: boolean;
  mockLLMHandler?: MockLLMHandler;
}

// Mock implementation of BaseLlmApi for testing
class MockLlmApi implements BaseLlmApi {
  private mockHandler: MockLLMHandler;

  constructor(mockHandler: MockLLMHandler) {
    this.mockHandler = mockHandler;
  }

  async completions(body: any, signal?: AbortSignal): Promise<any> {
    throw new Error("Not implemented - use stream completions");
  }

  async streamCompletion(
    body: any,
    signal?: AbortSignal,
    callbacks?: StreamCallbacks
  ): Promise<AsyncIterable<any>> {
    const messages = body.messages;
    
    // Get responses from mock handler
    const responses = await this.mockHandler.handleRequest(
      messages,
      callbacks?.onContent,
      callbacks?.onContentComplete,
      callbacks?.onToolStart,
      callbacks?.onToolResult,
      callbacks?.onToolError
    );

    // Convert responses to stream chunks
    return (async function* () {
      for (const response of responses) {
        if (response.role === "assistant" && response.content) {
          yield {
            choices: [{
              delta: { content: response.content },
              index: 0,
            }],
          };
        } else if (response.role === "assistant" && response.tool_calls) {
          for (const toolCall of response.tool_calls) {
            yield {
              choices: [{
                delta: {
                  tool_calls: [{
                    index: 0,
                    id: toolCall.id,
                    function: toolCall.function,
                  }],
                },
                index: 0,
              }],
            };
          }
        }
      }
    })();
  }

  async streamChat(
    body: any,
    signal?: AbortSignal
  ): Promise<AsyncIterable<any>> {
    return this.streamCompletion(body, signal);
  }

  async chat(body: any, signal?: AbortSignal): Promise<any> {
    throw new Error("Not implemented - use stream chat");
  }

  async rerank(body: any, signal?: AbortSignal): Promise<any> {
    throw new Error("Not implemented");
  }

  async embed(body: any, signal?: AbortSignal): Promise<any> {
    throw new Error("Not implemented");
  }

  async fimComplete(body: any, signal?: AbortSignal): Promise<any> {
    throw new Error("Not implemented");
  }
}

export async function createChatReplayTestContext(
  scenario: ChatHistoryTestScenario,
  options: ChatReplayOptions = {}
): Promise<ChatReplayTestContext> {
  const mockHandler = options.mockLLMHandler || new StaticMockLLMHandler(scenario.mockResponses || []);
  const mockLlmApi = new MockLlmApi(mockHandler);

  // Mock the required props
  const mockProps = {
    sessionId: options.sessionId || "test-session",
    model: options.model || "test-model",
    llmApi: mockLlmApi,
    isHeadless: false,
    intro: false,
    configPath: undefined,
    noTools: false,
    systemMessage: undefined,
    mcp: [],
    history: scenario.initialHistory || [],
  };

  const stdout: string[] = [];
  const stderr: string[] = [];

  // Render the TUIChat component
  const component = render(
    <TUIChat {...mockProps} />,
    {
      stdout: {
        write: (data: string) => {
          stdout.push(data);
          return true;
        },
      } as any,
      stderr: {
        write: (data: string) => {
          stderr.push(data);
          return true;
        },
      } as any,
    }
  );

  if (!options.skipInitialRender) {
    await component.waitUntilExit();
  }

  return {
    component,
    messages: [],
    chatHistory: scenario.initialHistory || [],
    mockHandler,
    lastStdout: stdout[stdout.length - 1] || "",
    stdout,
    rerender: () => component.rerender(<TUIChat {...mockProps} />),
  };
}

export async function replayChatHistoryStep(
  context: ChatReplayTestContext,
  step: ChatHistoryTestStep
): Promise<void> {
  // Add the message to history if provided
  if (step.message) {
    context.chatHistory.push(step.message);
    
    // If it's a user message, simulate user input
    if (step.message.role === "user") {
      // Find the UserInput component and simulate typing
      const { stdin } = context.component;
      if (stdin && step.message.content) {
        stdin.write(step.message.content);
        stdin.write("\r"); // Simulate enter key
      }
    }
    
    // Wait for UI to update
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  // Get current messages from the UI
  const frames = context.component.frames;
  const lastFrame = frames[frames.length - 1];
  
  // Extract messages from the rendered output
  // This is a simplified version - you might need to parse the actual UI output
  const displayedMessages = parseMessagesFromFrame(lastFrame);
  
  // Run validation
  if (step.validate) {
    step.validate(displayedMessages);
  }

  // Validate expected messages
  for (let i = 0; i < step.expectedMessages.length; i++) {
    const expected = step.expectedMessages[i];
    const actual = displayedMessages[i];
    
    if (!actual) {
      throw new Error(`Expected message at index ${i} but found none`);
    }
    
    if (expected.role !== actual.role) {
      throw new Error(
        `Expected message ${i} to have role "${expected.role}" but got "${actual.role}"`
      );
    }
    
    if (expected.content && !actual.content.includes(expected.content)) {
      throw new Error(
        `Expected message ${i} to contain "${expected.content}" but got "${actual.content}"`
      );
    }
    
    if (expected.messageType && expected.messageType !== actual.messageType) {
      throw new Error(
        `Expected message ${i} to have type "${expected.messageType}" but got "${actual.messageType}"`
      );
    }
  }
}

export async function runChatHistoryScenario(
  scenario: ChatHistoryTestScenario,
  options: ChatReplayOptions = {}
): Promise<void> {
  const context = await createChatReplayTestContext(scenario, options);
  
  try {
    for (const step of scenario.steps) {
      await replayChatHistoryStep(context, step);
    }
  } finally {
    // Clean up
    context.component.unmount();
  }
}

// Helper function to parse messages from rendered frame
// This is a simplified implementation - you'll need to adapt it based on actual UI output
function parseMessagesFromFrame(frame: string): any[] {
  const messages: any[] = [];
  
  // Simple parsing logic - you'll need to implement based on your UI output format
  const lines = frame.split("\n");
  
  for (const line of lines) {
    if (line.includes("●") && line.includes("You:")) {
      messages.push({
        role: "user",
        content: line.substring(line.indexOf("You:") + 4).trim(),
      });
    } else if (line.includes("●") && line.includes("Assistant:")) {
      messages.push({
        role: "assistant",
        content: line.substring(line.indexOf("Assistant:") + 10).trim(),
      });
    } else if (line.includes("○") || line.includes("✓") || line.includes("✗")) {
      // Tool messages
      messages.push({
        role: "tool",
        content: line.trim(),
        messageType: line.includes("○") ? "tool-start" : 
                     line.includes("✓") ? "tool-result" : "tool-error",
      });
    }
  }
  
  return messages;
}